\chapter{introduction}
\label{ch:intro}

\section{Research topic}
\label{sec:intro:Forschungsthema}
Graph databases have developed into a powerful tool for modeling and querying com-plex relations in various data types. 
They are particularly suitable for dealing with linked data and complex network structures that essentially consist of nodes and their edges (relations). 
Examples of use are e.g \citep{yuanyuan_tian_world_2022}:
\begin{itemize}
	\item Relationships in social networks
	\item Recommendation applications
	\item Biological networks
\end{itemize}
In this paper, the topic of graph databases and selected query languages designed for graph databases will be presented and contextualized. 
In particular, the path from different query languages to a uniform ISO standard is pointed out.


\section{Motivation}
\label{sec:intro:Motivation}
The aim of this paper is to provide an overview of the different languages and to highlight the respective advantages and disadvantages, 
their capabilities, and limitations, as well as their specific use cases. 

\section{State of research}
\label{sec:intro:State of researc}
Graph databases are a comparatively young technology in the field of database systems. 
Over time, various query languages have been developed with specific focuses and corresponding strengths and weaknesses.
A common ISO standard should help to keep the technology and its application more generic \citep{hare_isoiec_2024}.
In this paper, important proprietary languages are presented and differentiated from each other. 
In the further course, a overview of the different languages is created.

\section{Approach}
\label{sec:intro:Approach}
Basically, relevant documentation on the various query languages is analyzed and the key points are highlighted. 
To support this, selected languages are tried out in a test project and the corresponding learnings are integrated into the work.


\chapter{Criteria for comparison}
First, comparative criteria are introduced against which the different languages are compared.

The evaluation is done purely qualitatively as this is a complex topic that is difficult to evaluate on the basis of a uniform scale. 
Nevertheless, the aim is to evaluate the languages as objectively and reproducibly as possible on the basis of the defined criteria.

\section{Expressiveness}
Expressiveness in the context of query languages for graph databases means the ability 
of a language to allow a wide range of queries on graphs and their underlying databases.
An expressive language can be used with
\begin{itemize}
	\item complex patterns
	\item relationships
\end{itemize}
even across various different graphs.
In addition, an expressive language offers users the corresponding flexibility
when querying graph structures.

\section{Ease of Use}
For users, it is important that the corresponding query language is intuitive to understand, follows familiar and learned patterns 
and is as close as possible to the de facto industry standard. 
On the other hand, a less intuitive language means an increased learning curve, 
which makes the technology more difficult to use.

\section{Performance and Performance Optimization}
Performance is a decisive factor when dealing with the analysis of large amounts of data. 
Especially when it comes to evaluations that need to be carried out in real time or very quickly. 
A recommendation system does not help anyone if it does not deliver an answer in a reasonable time.
This criterion evaluates in particular the ability of the corresponding language to enable techniques 
that improve the performance of queries on graph databases.
Particular attention is paid to the following two factors:
\begin{itemize}
	\item Implementation of index-based structures
	\item Parallel processing
\end{itemize}
* Implementation of index-based structures
* Parallel processing

\section{Interoperability}
How well a query language intergrates with other tools, techniques and API`s is an important
criteria for the decision for and against the query language and often for the entire 
database system.

\section{Closeness to the ISO standard}
n particular, attention is paid to the extent to which the respective language is oriented 
towards the ISO standard for query languages for graph databases.
A language that is strongly oriented towards the ISO standard or whose model and structure 
has a high proportion of the ISO standard automatically ensures, 
that the user has to acquire a low level of proprietary knowledge, 
which is beneficial to the user-friendliness of the language.
In addition, a strong orientation towards the ISO standard ensures interoperability 
with other technologies and systems, 
as it can be assumed that these are also oriented towards at least the basic concepts of the ISO standard.

In the next chapter the ISO-standard for Graph databases will be introduced to enable the reader 
to compare the corresponding language with the ISO-standard when reading chapter XXX.

\chapter{The ISO-standard for query languages for graph databases}
\section{Overview of the GQL-standard}
In short, GQL is a new standard for a property graph database language developed by 
international standards committee.
GQL is an acronym for Graph Query Language.
It is the first time in more than 35 years, that the ISO released a new 
standard for database query language.

In opposite to SQL, where data is organized in tables, graph databases structure data in graphs. 
This enables new ways to analyze and recognize patterns in very large amounts of 
data without having specific knowledge about the data itself.
Various use cases for graph databases have already been mentioned in chapter xxx.
\section{Scope of the GQL-standard}
As already mentioned graph databases store and retrieve nodes (vertexes) and
edges between nodes (relationships). GQL is a delclarative language influenced both by 
existing property graph database products and by the SQL standard.
The GQL standard is a complete database language that supports
\begin{itemize}
	\item creating
	\item reading
	\item updating
	\item deleting
	\item modifying
\end{itemize}
property graph data. \\
Graph data can be organized in two different ways:
\begin{itemize}
    \item Schema free or
    \item constrained by an database administrator.
\end{itemize}
Schema free graph data has no restrictions for adding and changing graph data.
Graph data that is subject to a predefined schema must fulfill this at all times, 
otherwise an error is triggered.\\
The schema of graph data is specified via so-called graph types, 
which on the one hand specify the structure of the nodes as well as that of the edges, 
i.e.the relationships between the nodes.
\section{Examples of common GQL query operations}
This chapter provides a brief introductionto GQL capabilities including
\begin{itemize}
	\item Queries and Graph Pattern Matching
	\item Add, modify and delete operations
	\item Transactions
\end{itemize}
\subsection{Queries and Graph Pattern Matching}
GQL quries are based on rich Graph Pattern Matching (GPM) language.
The below example findes all nodes with a one-hop relationship to a node with a 
productId of \textit{6594301c4aa9b3232889e7c3}
\begin{lstlisting}
    {
       MATCH (a {productId: "6594301c4aa9b3232889e7c3"}) - [b] -> (c)
	   RETURN a, b, c

    }
\end{lstlisting}

The GQL-standard does not define how the returned data has to be displayed
to the user. Two possible ways can be:
\begin{itemize}
	\item Graph Data Visualization tools
	\item Textoutput
\end{itemize}
Here is suggestion how the above listing TODO can be displayed:
This below table shows how the output can be displayed as text \\
TODO table erstellen

\section{Schema free vs graph types}
A schema free graph accepts any form of graph data which makes it relatively fast to use 
but on the other hand gives the user control over the data 
and therefore a certain amount of data proliferation is accepted and has to be managed.\\
A graph type is a kind of template that specifies the structure of the graph, which must be adhered to at all times.
The structure of the nodes as well as the edges or both can be specified.
The following example illustrates the concept of a graph type
\begin{lstlisting}
    {
       CREATE GRAPH TYPE /folder
       (client: Client => {cid::STRING, cname::STRING}),
       (agent:Agent => {no::STRING, office::STRING}),
       (client)-[:SUPERVISED_BY]->(agent)

    }
\end{lstlisting}

